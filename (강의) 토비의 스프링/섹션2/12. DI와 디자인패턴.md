- 아래 사진은 디자인패턴을 목적과 범위에 따라 나눈 것이다.

    <center>
      <img
          src="https://github.com/user-attachments/assets/c48d423b-3411-4c3a-9a2a-6d8f159fa5b2"
          width="100%"
      />
    </center>

- 위 사진에서 집중할 곳은 Scope 쪽이다.

  상속은 앞에서 말했듯이 서로 밀접한 연관 관계를 가지고 있고 상위 클래스가 변경되면 하위 클래스에도 직접적인 영향을 끼치게 되는 단점이 있다고 말했었다.

  그래서 합성으로 해결할 수 있다면 합성을 먼저 고려하는 것이 좋다.

- 합성은 DI와 연관있다. 합성과 관련된 디자인 패턴은 의존성 주입을 통해 서로 협력하고 동작한다.

- 앞에서 짠 코드를 다시보면 환율 정보를 필요할 때마다 계속해서 조회하는 방식으로 동작하고 있다. 근데 갑자기 사용자가 엄청 몰려서 요청을 보내면 인터넷을 통해 환율을 매번 가지고 와야한다는 단점이 있다.

  이럴꺼면 캐시해놓고 필요할 때마다 캐시한 데이터를 주는게 낫지않나 라는 생각이든다.

  물론 환율 정보가 변경될 수 있기 때문에 일정 시간동안만 캐시가 유지되는 방식으로 동작하게 코드를 변경했다.

  이는 데코레이터 패턴을 사용한다.

  그래서 아래와 같은 구조가 된다.

    <center>
      <img
          src="https://github.com/user-attachments/assets/1d51bbd8-a3a1-448e-b20b-0bd85ab9444f"
          width="100%"
      />
    </center>

  최종적으로는 아래 구조가 된다.

    <center>
      <img
          src="https://github.com/user-attachments/assets/a38f031c-a4bb-4f7f-a587-3471006e230f"
          width="100%"
      />
    </center>

- 아래는 코드로 적용한 것이다.

  아래 코드를 보면 알 수 있듯이 캐시를 담당하는 클래스가 새롭게 추가됐다고 기존의 코드가 변경은 일어나지않았다.

  물론 ObjectFactory는 변경이 일어났지만 의존 관계에 대한 구성정보를 담고 있기 때문에 이 친구의 변경은 허용한다.

  하지만 제일 중요한 것은 기존의 코드에 변경이 일어나지 않았다는 것이다.

  스프링을 사용해 개발하면 어떻게 DI를 활용할 것인지 고민하며 개발을 해야겠다고 생각이 들었다.

  ```java
  // 캐시의 기능을 담당
  public class CachedExRateProvider implements ExRateProvider {
      private final ExRateProvider target;

      private BigDecimal cachedExRate;
      private LocalDateTime cacheExpiryTime;

      public CachedExRateProvider(ExRateProvider target) {
          this.target = target;
      }

      @Override
      public BigDecimal getExRate(String currency) throws IOException {
          if(cachedExRate == null || cacheExpiryTime.isBefore(LocalDateTime.now())) {
              cachedExRate = target.getExRate(currency);
              cacheExpiryTime = LocalDateTime.now().plusSeconds(3);

              System.out.println("cache updated");
          }

          return cachedExRate;
      }
  }





  @Configuration
  public class ObjectFactory {
      @Bean
      public PaymentService paymentService() {
          return new PaymentService(cachedExRateProvider());
      }

      @Bean
      public ExRateProvider cachedExRateProvider() {
          return new CachedExRateProvider(exRateProvider());
      }

      @Bean
      public ExRateProvider exRateProvider() {
          return new SimpleExRateProvider();
      }
  }

  ```
