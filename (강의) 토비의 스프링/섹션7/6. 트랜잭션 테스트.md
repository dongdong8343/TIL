트랜잭션이 제대로 적용됐는지 테스트 하기는 쉽지않다.

JDBC는 자동으로 커밋을 해주고, Spring Data Jpa는 기본 리포지토리 구현에서 트랜잭션을 알아서 적용시켜준다.

하지만 이렇게 되면 어느 시점에 트랜잭션이 동작했는지 판단하기 어렵다. 왜냐하면 하나의 트랜잭션으로 동작했는지 아니면 여러 트랜잭션으로 동작했는지 알기어렵다.

그래서 테스트 도중에 실패가 발생하면 롤백을 하는지 여부로 판단할 수 있긴 하다.

1. OrderService에 여러 개의 Order를 저장하는 메서드 생성

   Order를 하나 저장할 때마다 새로운 트랜잭션이 만들어져서 중간에 Order를 넣다가 에러가 발생하면 기존에 넣었던 Order를 다 취소해야한다.

   그래서 TransactionTemplate을 통해 하나의 트랜잭션을 보장해주는 코드를 작성했다.

   ```java
   @Service
   public class OrderService {
       ...

       public List<Order> createOrders(List<OrderRequest> requests) {
           return new TransactionTemplate(transactionManager).execute(status ->
               requests.stream().map(orderRequest -> createOrder(orderRequest.no(), orderRequest.total())).toList()
           );
       }
   }
   ```

2. OrderServiceSpringTest에 테스트 코드 작성하기

   Order를 넣는 중간에 실패를 하면 앞에 넣었던 Order도 반환되는지 테스트 하는 것이다.

   ```java
   @Test
       void createDuplicateOrders() {
           List<OrderRequest> orderRequests = List.of(
               new OrderRequest("0300", BigDecimal.ONE),
               new OrderRequest("0300", BigDecimal.TWO)
           );

           // 예외가 던져지면 테스트가 성공함.
           // no에는 unique 값만 들어갈 수 있어서 예외가 던져짐.
           assertThatThrownBy(() -> orderService.createOrders(orderRequests))
               .isInstanceOf(DataIntegrityViolationException.class);

           JdbcClient client = JdbcClient.create(dataSource);
           Long count = client.sql("select count(*) from orders where no = '0300'").query(Long.class).single();

           assertThat(count).isEqualTo(0);
       }
   ```
