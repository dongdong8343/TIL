- 스프링부트 프로젝트로 생성
  1. new Project > SpringBoot

  <center>
  <img
      src="https://github.com/user-attachments/assets/dd472ef1-ce74-424a-924b-67092c88c62f"
      width="100%"
  />
  </center>

  2. spring에 필요한 최소한의 라이브러리만 사용할 예정이라서 그냥 create 버튼 클릭

### 개발 방법

1. 적당한 단위로 쪼개서 작업 수행

   → 한 번에 너무 많은 양을 진행해버리고 결과 확인하면 어디서 에러가 나는지 파악하기 어렵다는 단점이 존재

2. 작성한 코드 제대로 동작하는지 확인 → 테스트
3. 조금씩 기능 추가하며 검증
4. 코드를 한눈에 파악하기 힘들면 주석 달기

### IntelliJ IDEA 사용

- Gradle 사용하면 콘솔에 출력되는 양도 많고 IntelliJ IDEA 보다 조금 느리다.

    <center>
        <img
            src="https://github.com/user-attachments/assets/25deccbe-0bb2-46d4-8c15-b12709c66c38"
            width="100%"
        />
    </center>

### PaymentService 개발

- 요구사항

  - 해외 직구를 위한 원화 결제 준비 기능
  - 주문 번호, 외국 통화 종류, 외국 통화 기준 결제 금액 전달 받은 후 적용환율, 원화 환산 금액, 원화 환산 금액 유효시간을 더해 Payment를 생성

- 코드는 아래와 같다.

  ```java
  public class PaymentService {

  	public Payment prepare(Long orderId, String currency, BigDecimal foreignCurrencyAmount) throws
  		IOException {
  		// 환율 가져오기 https://open.er-api.com/v6/latest/USD
  		URL url = new URL("https://open.er-api.com/v6/latest/" + currency);
  		HttpURLConnection connection = (HttpURLConnection)url.openConnection();
  		BufferedReader br = new BufferedReader(
  			new InputStreamReader(connection.getInputStream()));
  		String response = br.lines().collect(Collectors.joining());
  		br.close();

  		ObjectMapper mapper = new ObjectMapper();
  		ExRateData data = mapper.readValue(response, ExRateData.class);
  		BigDecimal exRate = data.rates().get("KRW");

  		// 금액 계산
  		BigDecimal convertedAmount = foreignCurrencyAmount.multiply(exRate);

  		// 유효 시간 계산
  		LocalDateTime validUntil = LocalDateTime.now().plusMinutes(30);

  		return new Payment(orderId, currency, foreignCurrencyAmount, exRate, convertedAmount, validUntil);
  	}

  	public static void main(String[] args) throws IOException {
  		PaymentService paymentService = new PaymentService();
  		Payment payment = paymentService.prepare(100L, "USD", BigDecimal.valueOf(50.7));
  		System.out.println(payment);
  	}
  }

  ```

  ```java
  // 리턴하는 모든걸 안받기 때문에 아래 필드에 없는게 json에 있어도 실행이 잘됨
  @JsonIgnoreProperties(ignoreUnknown = true)
  public record ExRateData(String result, Map<String, BigDecimal> rates) {
  }

  ```

  ```java
  public class Payment {
  	private Long orderId;
  	private String currency;
  	private BigDecimal foreignCurrencyAmount;
  	private BigDecimal exRate;
  	private BigDecimal convertedAmount;
  	private LocalDateTime validUntil;

  	public Payment(Long orderId, String currency, BigDecimal foreignCurrencyAmount, BigDecimal exRate,
  			BigDecimal convertedAmount, LocalDateTime validUntil) {
  			this.orderId = orderId;
  			this.currency = currency;
  			this.foreignCurrencyAmount = foreignCurrencyAmount;
  			this.exRate = exRate;
  			this.convertedAmount = convertedAmount;
  			this.validUntil = validUntil;
  	}

  	// get 메서드들..

  	// toString()
  }

  ```

  - 여기서 의문인 점들 찾아봤다.

  1. **Double이 아닌 BigDecimal을 사용하는 이유**
     - Double은 계산 과정에서 소수점 오차가 발생할 여지가 있다.
     - BigDecimal은 10진수 기반으로 수를 저장해서 소수점 아래 자리도 정확한 연산이 가능하다.
       즉 환율, 돈과 같이 정확한 연산이 필요한 곳에서는 Double이 아니라 BigDecimal을 사용한다.
       객체 기반이라 연산 속도가 느리다는 단점이 있다. 그래서 정확도가 요구되는 곳에서 사용하자.
  2. BufferedReader

     ```java
     // getInputStreamReader는 바이트 단위로 데이터를 다룬다.
     // InputStreamReader를 통해 바이트 단위의 데이터를 문자 스트림으로 변환
     // BufferedReader를 통해 버퍼링 기능 제공 -> 한 문장씩 읽기도 가능
     BufferedReader br = new BufferedReader(
                 new InputStreamReader(connection.getInputStream()));

     // br의 모든 줄을 Stream<String> 형태로 바꾸고 스트림의 모든 문자열을 하나로 합
     String response = br.lines().collect(Collectors.joining());
     ```

  3. ObjectMapper

     - 자바 객체와 JSON 문자열 간 변환할 때 사용한다.

     ```java
     ObjectMapper mapper = new ObjectMapper();
     // json 문자열을 ExRateData라는 Java 클래스 객체로 변환
     ExRateData data = mapper.readValue(response, ExRateData.class);
     BigDecimal exRate = data.rates().get("KRW");
     ```

  4. record

     - 쉽게 불변 객체를 정의 가능 ⇒ 안정성과 신뢰성
     - 자동으로 private final 필드, 생성자, getter 역할의 accessor 메서드 제공

     ```java
     // 리턴하는 모든걸 안받기 때문에 아래 필드에 없는게 json에 있어도 실행이 잘됨
     @JsonIgnoreProperties(ignoreUnknown = true)
     public record ExRateData(String result, Map<String, BigDecimal> rates) {
     }
     ```
