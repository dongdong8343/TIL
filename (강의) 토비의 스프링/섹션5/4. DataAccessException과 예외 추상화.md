- JDBCSQLException

  - JDBC를 기반으로 하는 모든 기술에서 발생하는 예외

  - DB에서 발생하는 모든 문제를 에러 코드로 던져주기 때문에 에러코드를 보고 문제를 세분화 시켜야하는 문제가 있었다.

- DataAccessException

    <center>
      <img
          src="https://github.com/user-attachments/assets/fd6d057f-4712-4fe9-9d7c-fb30bd63ede6"
          width="100%"
      />
    </center>

  - 스프링이 DB와 관련되 예외가 발생하면 그에 맞는 예외로 번역해서 던져준다.

  - 앞에서 만들었던 EntityManager 방식을 사용하는 것은 스프링이 끼어들 틈이 없다. 그래서 추상화된 예외를 던질 수 없다는 문제가 있다.

    그래서 이를 해결하는 방법을 아래에서 소개한다.

  1. Repository에서 트랜잭션마다 엔티티 메니저를 통해 작업 수행

     ```java
     public class OrderRepository {
         @PersistenceContext
         private EntityManager em; // 트랜잭션마다 새롭게 만들어진다.

         public void save(Order order) {
             em.persist(order);
         }
     }
     ```

  2. DataConfig의 구성 정보 설정

     ```java
     @Configuration
     public class DataConfig {
         // data source
         @Bean
         public DataSource dataSource() {
             return new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2).build();
         }

         // entity manager factory
         @Bean
         public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
             LocalContainerEntityManagerFactoryBean emf = new LocalContainerEntityManagerFactoryBean();
             emf.setDataSource(dataSource());
             emf.setPackagesToScan("tobyspring.tobyspring");
             emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter() {{
                     setDatabase(Database.H2);
                     setGenerateDdl(true);
                     setShowSql(true);
             }});

             return emf;
         }

         @Bean
         public BeanPostProcessor persistenceAnnotationBeanPostProcessor() {
             return new PersistenceAnnotationBeanPostProcessor();
         }

         @Bean
         public JpaTransactionManager transactionManager(EntityManagerFactory emf) {
             return new JpaTransactionManager(emf);
         }

         @Bean
         public OrderRepository orderRepository() {
             return new OrderRepository();
         }
     }
     ```

  3. 스프링에서 제공하는 트랜잭션 템플릿 사용

     ```java
     public class DataClient {
         public static void main(String[] args) {
             BeanFactory beanFactory = new AnnotationConfigApplicationContext(DataConfig.class);
             OrderRepository repository = beanFactory.getBean(OrderRepository.class);
             JpaTransactionManager transactionManager = beanFactory.getBean(JpaTransactionManager.class);

             // 스프링에서 제공하는 트랜잭션 템플릿
             // 사용하기 위해서 콜백 함수를 정의해줘야 함.
             try {
                 new TransactionTemplate(transactionManager).execute(status -> {
                     Order order = new Order("100", BigDecimal.TEN);
                     repository.save(order);
                     System.out.println(order);

                     Order order2 = new Order("100", BigDecimal.ONE);
                     repository.save(order2);

                     return null;
                 });
             } catch (DataIntegrityViolationException e) {
                 System.out.println("주문번호 중복 복구 작업");
             }
             // commit
         }
     }
     ```

  위와 같은 과정을 거치면 어떤 기술을 사용하더라도 추상화 된 예외를 받아 처리할 수 있게 된다.

- 스프링은 어떤 기술을 사용더라도 예외를 추상화해서 적절하게 번역해서 예외를 던져준다. 그래서 예외를 처리하는 부분의 코드가 기술에 따라 변경이 안되도록 도와주는 역할도 한다.
