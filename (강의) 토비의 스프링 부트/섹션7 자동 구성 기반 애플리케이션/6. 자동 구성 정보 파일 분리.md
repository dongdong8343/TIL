### 자동 구성 정보 파일 분리

구성 클래스들을 하드 코딩 했었는데 그러지않고 외부 파일로 빼서 구성 클래스들을 동적으로 가져올 수 있도록 만들 것이다.

일단 자동 구성 클래스라는 의미를 가진 메타 애노테이션을 만든다.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Configuration
public @interface MyAutoConfiguration {
}
```

위 애노테이션 이름을 기반으로 외부 파일을 읽어올 것이다.

외부 파일은 META-INF/spring/`tobyspring.config.MyAutoConfiguration.import` 와 같은 형태로 있어야한다.

```java
tobyspring.config.autoconfig.DispatcherServletConfig
tobyspring.config.autoconfig.TomcatWebServerConfig
```

그리고 외부 파일을 읽어서 구성 클래스를 읽어오는 코드를 MyAutoConfigImportSelector에 작성한다.

```java
public class MyAutoConfigImportSelector implements DeferredImportSelector {
	private final ClassLoader classLoader;

	public MyAutoConfigImportSelector(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}

	@Override
	public String[] selectImports(AnnotationMetadata importingClassMetadata) {
		List<String> autoConfigs = new ArrayList<>();

		ImportCandidates.load(MyAutoConfiguration.class, classLoader).forEach(autoConfigs::add);

		return autoConfigs.toArray(new String[0]);
	}
}

```

우리가 직접 @Configuration을 사용해서 직접 코드를 작성해서 빈으로 등록하는 경우가 있다.

그래서 @Configuration의 동작 방식을 이해하고 있을 필요가 있다.

<center>
  <img
    src="https://github.com/user-attachments/assets/d003ca86-8faa-4fe0-a03b-5232e49ca08c"
    width="50%"
  />
</center>

외부 파일을 `DeferredImportSelector` 를 구현한 클래스를 통해서 읽어서 구성 클래스들을 동적으로 읽어왔었다.

그리고 이 동적 파일에서 읽어온 구성 클래스를 필요할 때 빈으로 등록한다는 것을 확인했다.
