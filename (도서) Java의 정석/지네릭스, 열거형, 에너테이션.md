## 지네릭스

다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시 타입 체크해주는 기능이다.

```java
class Box<T> {
    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}
```

만약 T 자리에 Object라고 작성을 했다면 매번 타입을 검사해야하고 여간 힘든일이 아니였을 것이다..

나중에 사용할 때는 아래와 같이 사용할 수 있다.

```java
public class GenericExample1 {
    public static void main(String[] args) {
        // String 타입으로 지정
        Box<String> stringBox = new Box<>();
        stringBox.set("Hello Generics");
        System.out.println(stringBox.get());

        // Integer 타입으로 지정
        Box<Integer> intBox = new Box<>();
        intBox.set(100);
        System.out.println(intBox.get());
    }
}
```

### 제한된 지네릭 클래스

지네릭 타입에 extends를 사용하면 특정 타입의 자손들만 대입 가능하다.

```java
// Number를 상속한 타입만 가능
class Box<T extends Number> {
    private T value;

    public void set(T value) {
        this.value = value;
    }

    public double getDoubleValue() {
        return value.doubleValue();
    }
}

public class GenericExtendsExample1 {
    public static void main(String[] args) {
        Box<Integer> intBox = new Box<>();   // OK (Integer는 Number의 자손)
        intBox.set(10);
        System.out.println(intBox.getDoubleValue());

        Box<Double> doubleBox = new Box<>(); // OK (Double도 Number의 자손)
        doubleBox.set(3.14);
        System.out.println(doubleBox.getDoubleValue());

        // Box<String> strBox = new Box<>(); // 오류! String은 Number를 상속하지 않음
    }
}
```

## 와일드 카드

지네릭 타입은 컴파일러가 컴파일 할 때만 사용하고 제거해버린다는 특징이 있다.

그렇기 때문에 특정 클래스만 와서 특정 클래스만 사용할 수 있도록 하는 것이 아니라 특정 클래스의 조상, 자손들도 사용 가능하도록 할 수 있다.

```java
import java.util.*;

class Animal {
    void sound() { System.out.println("Animal sound"); }
}
class Dog extends Animal {
    void sound() { System.out.println("Woof!"); }
}
class Cat extends Animal {
    void sound() { System.out.println("Meow!"); }
}

public class WildcardExample2 {
    // Animal 또는 그 자손만 받을 수 있음
    public static void printAnimalSounds(List<? extends Animal> list) {
        for (Animal a : list) {
            a.sound(); // 안전하게 Animal 메서드 사용 가능
        }
    }

    public static void main(String[] args) {
        List<Dog> dogs = Arrays.asList(new Dog(), new Dog());
        List<Cat> cats = Arrays.asList(new Cat(), new Cat());

        printAnimalSounds(dogs);
        printAnimalSounds(cats);
        // printAnimalSounds(new ArrayList<String>()); // 오류!
    }
}
```

```java
import java.util.*;

public class WildcardExample3 {
    // Number의 조상 타입 (Number, Object 등) 가능
    public static void addNumbers(List<? super Integer> list) {
        list.add(10); // Integer 추가 가능
        list.add(20);
        // list.add(3.14); // 오류! Double은 불가
    }

    public static void main(String[] args) {
        List<Integer> intList = new ArrayList<>();
        List<Number> numList = new ArrayList<>();
        List<Object> objList = new ArrayList<>();

        addNumbers(intList); // Integer 허용
        addNumbers(numList); // Number 허용
        addNumbers(objList); // Object 허용
    }
}
```

## 지네릭 타입의 형변환

```java
Box box = null;
Box<Object> objBox = null;

box = (Box)objBox;
objBox = (Box<Object>)box;
```

위의 코드처럼 제네릭과 넌제네릭 타입간의 형변환은 항상 가능하다. 왜냐하면 런타임 시 제네릭은 사라져서 가능하기 때문이다. 하지만 이건 권장하지 않는다.

타입의 안정성이 보장이 안되기 때문이다.

## 지네릭 타입의 제거

1. 지네릭 타입의 경계를 제거한다.

```java
<T extends Fruit>라면 T는 Fruit로 치환됨
```

2. 지네릭 타입을 제거한 후 타입이 일치하지 않으면, 형변환을 추가한다.

```java
T get(int i) {
    return list.get(i);
}

=>

Fruit get(int i) {
    return (Fruit)list.get(i);
}
```

## 열거형(enums)

서로 관련된 상수들을 편리하게 관리할 수 있게 해준다.

사용법은 아래와 같다.

```java
enum 열거형이름 { 상수명1, 상수명2, ... }
```

멤버가 있는 경우 아래와 같이 추가할 수 있다.

참고로 생성자는 private인데 외부에서 임의로 생성되는 것을 막기 위함이다.

```java
enum Day {
    MONDAY("월요일"),
    TUESDAY("화요일"),
    WEDNESDAY("수요일"),
    THURSDAY("목요일"),
    FRIDAY("금요일"),
    SATURDAY("토요일"),
    SUNDAY("일요일");

    // 멤버 변수
    private final String korean;

    // 생성자 (enum은 private만 가능)
    Day(String korean) {
        this.korean = korean;
    }

    // getter
    public String getKorean() {
        return korean;
    }
}
```

## 애너테이션

프로그래밍 언어에 영향을 미치지 않고 다른 프로그램에게 유용한 정보를 제공하는 역할을 한다.

즉 코드에는 영향을 끼치지 않지만 애너테이션을 통해 컴파일러가 무슨 역할을 하는 친구인지 파악할 수 있다.

대표적인 애너테이션으로는 @Override가 있다.

### @Override

```java
class Child extends Parent {
    @Override
    void parentmethod() {}
}
```

이렇게 작성함으로써 오버라이딩을 할 때 메서드 이름이 동일한지 미리 파악하고 미연에 실수하는 것을 방지할 수 있다.

### @Deprecated

기존에 코드가 있었는데 다른 코드로 대체되는 경우가 있다. 그렇다고 기존 코드를 없애버리면 이미 만들어진 프로그램에 영향을 끼치게된다.

그래서 해당 애너테이션을 사용해서 이 코드는 더 이상 사용하지 않는 코드라는 것을 알려준다.

### @FunctionalInterface

함수형 인터페이스를 선언할 때 사용한다.

컴파일러가 함수형 인터페이스를 올바르게 선언했는지 확인하고 잘못된 경우 에러를 던져준다.

함수형 인터페이스는 추상 메서드가 딱 하나만 있는 인터페이스를 의미한다.

### @SuppressWarnings

컴파일러가 보여주는 경고메시지가 나타나지 않게 해준다.

## 메타 애너테이션

에너테이션을 위한 에너테이션을 의미한다.

애너테이션의 적용대상, 유지기간 등을 지정하는데 사용한다.

### @Target

애너테이션이 적용가능한 대상을 지정하는데 사용한다.

여러 개의 값을 지정할 때는 배열에서처럼 {}를 사용해야한다.

```java
import java.lang.annotation.*;

@Target({ElementType.TYPE, ElementType.FIELD})
@interface Info {
    String value();
}

@Info("클래스 정보")
class Person {
    @Info("이름 필드")
    private String name;
}
```

적용대상의 종류는 아래와 같다.

TYPE → 클래스, 인터페이스, enum, 애너테이션에 적용

METHOD → 메서드에 적용

FIELD → 멤버 변수에 적용

PARAMETER → 메서드 매개변수에 적용

CONSTRUCTOR → 생성자에 적용

LOCAL_VARIABLE → 지역 변수에 적용

ANNOTATION_TYPE → 다른 애너테이션에 적용

PACKAGE → 패키지에 적용

TYPE_PARAMETER → 제네릭 타입 매개변수에 적용 (Java 8+)

TYPE_USE → 모든 타입 선언부에 적용 가능 (Java 8+)

### @Retention

애너테이션이 언제까지 유지될 것인지 지정하는데 사용된다.

**RetentionPolicy 종류**

- SOURCE

  소스 코드에서만 존재

  컴파일하면 사라짐 (바이트코드에 기록되지 않음)

  주로 컴파일러에 지시하는 용도 (예: @Override, @SuppressWarnings)

- CLASS (기본값)

  컴파일 시 .class 파일에 남지만, 런타임 JVM 메모리에는 로딩되지 않음

  바이트코드 수준 도구(예: 바이트코드 조작 라이브러리)에서는 볼 수 있지만, 런타임 리플렉션에서는 못 봄

- RUNTIME

  런타임까지 유지되어, JVM에서 실행 중에도 리플렉션으로 읽을 수 있음

  프레임워크(Spring, JPA, Hibernate 등)에서 자주 사용됨

  예: @Entity, @Controller

### @Documented

애너테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 한다.

### @Inherited

애너테이션이 자손 클래스에 상속되도록 한다.

### @Repeatable

하나의 애너테이션을 같은 대상에 여러 번 붙일수 있다.

### @Native

네이티브 메서드에 의해 참조되는 상수 필드에 붙이는 애너테이션을 말한다.

여기서 네이티브 메서드는 JVM이 설치된 OS의 메서드를 의미한다.

## 애너테이션 타입 정의하기

직접 애너테이션을 만들 수도 있다.

애너테이션을 정의하는 방법은 아래와 같다.

```java
public @interface 애너테이션이름 {
    타입 요소이름() default 기본값;
}
```

애너테이션의 요소는 반환값이 있고 매개변수는 없는 추상 메서드의 형태를 가진다.

애너테이션을 적용할 때 이 요소들의 값을 빠짐없이 지정해줘야해서 순서는 상관없다.

그리고 위 코드를 보면 알 수 있듯이 기본값을 가질 수 있다.

## 애너테이션 요소의 규칙

- 요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용된다.

- ()안에 매개변수를 선언할 수 없다.

- 예외를 선언할 수 없다.

- 요소를 타입 매개변수로 정의할 수 없다.
