이번에 말하는 서비스는 애플리케이션 서비스를 의미하고 3계층 중에 가운데 계층을 의미한다.

1. OrderService 구현

   DB에 저장하는 동작을 할 때 트랜잭션 내부에서 동작을 보장해야돼서 TransactionTemplate을 사용했다.

   ```java
   @Service
   public class OrderService {
       private final OrderRepository orderRepository;
       private final JpaTransactionManager jpaTransactionManager;

       public OrderService(OrderRepository orderRepository, JpaTransactionManager jpaTransactionManager) {
           this.orderRepository = orderRepository;
           this.jpaTransactionManager = jpaTransactionManager;
       }

       public Order createOrder(String no, BigDecimal total) {
           Order order = new Order(no, total);

           return new TransactionTemplate(jpaTransactionManager).execute(status -> {
               this.orderRepository.save(order);

               return order;
           });
       }
   }
   ```

2. OrderConfig에 구성 정보를 작성

   OrderService를 생성했으니까 필요한 의존 관계를 맺어줘야한다.

   ```java
   @Configuration
   @Import(DataConfig.class) // OrderConfig 가져올 때 DataConfig도 가져옴.
   public class OrderConfig {
       @Bean
       public OrderService orderService(JpaTransactionManager transactionManager) {
           return new OrderService(orderRepository(), transactionManager);
       }

       @Bean
       public OrderRepository orderRepository() {
           return new OrderRepository();
       }
   }
   ```

3. Client에서 Service를 통해 Order를 저장하는 메서드를 호출

   ```java
   public class OrderClient {
       public static void main(String[] args) {
           BeanFactory beanFactory = new AnnotationConfigApplicationContext(OrderConfig.class);
           OrderService service = beanFactory.getBean(OrderService.class);

           Order order = service.createOrder("0100", BigDecimal.TEN);

           System.out.println(order);
       }
   }
   ```
