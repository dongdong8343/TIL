- 템플릿

  - 고정된 틀 안에 바꿀 수 있는 부분을 넣어서 사용할 수 있는 오브젝트

  - 틀을 만드는 가장 큰 이유 -> 재사용

- 템플릿 메서드 패턴

  - 고정된 틀의 로직을 가진 템플릿 메서드를 슈퍼 클래스에 두고 바뀌는 부분을 서브클래스의 메서드에 두는 구조를 말한다.

  - 템플릿 메서드 패턴은 상속 기반으로 동작하고 위에서 말한 템플릿, 콜백은 합성을 기반으로 동작한다.

  - 상속을 기반으로 동작하면 상위 클래스와 하위 클래스가 밀접한 관계를 가지고 있고 상위 클래스가 변경되면 하위 클래스에도 영향을 끼친다는 단점이 있다고 했었다.

1. 일단 메서드로 분리한다.

   메서드 명을 작성할 때는 목적이 나타나게 지어야 한다.

   ```java
   @Component
   public class WebApiExRateProvider implements ExRateProvider {
       @Override
       public BigDecimal getExRate(String currency) {
           String url = "https://open.er-api.com/v6/latest/" + currency;

           return runApiForExRate(url);
       }

       private static BigDecimal runApiForExRate(String url) {
           URI uri;
           try {
               uri = new URI(url);
           } catch (URISyntaxException e) {
               throw new RuntimeException(e);
           }

           String response;
           try {
               response = executeApi(uri);
           } catch (IOException e) {
               throw new RuntimeException(e);
           }

           try {
               return extractExRate(response);
           } catch (JsonProcessingException e) {
               throw new RuntimeException(e);
           }
       }

       private static BigDecimal extractExRate(String response) throws JsonProcessingException {
           ObjectMapper mapper = new ObjectMapper();
           ExRateData data = mapper.readValue(response, ExRateData.class);
           return data.rates().get("KRW");
       }

       private static String executeApi(URI uri) throws IOException {
           String response;
           HttpURLConnection connection = (HttpURLConnection)uri.toURL().openConnection();

           try (BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
               response = br.lines().collect(Collectors.joining());
           }
           return response;
       }
   }
   ```
