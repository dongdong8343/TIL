### 1. **UserValidator에 있는 비밀번호 검증하는 로직들을 Password 객체로 분리**

- 비밀번호 검증과 관련된 로직을 Password 객체로 분리함으로써 검증 로직이 응집력 있게 관리됨.
- 또한 정책이 변경되더라도 UserValidator를 수정하지않고 Password만 수정하면됨.
- `user - model - Password`
  ```java
  @AllArgsConstructor
  @Getter
  public class Password {
  	private static final int MIN_PASSWORD_LENGTH = 8;
  	private static final int MIN_PASSWORD_COMPLEXITY = 2;
  	private static final int BAD_SEQUENCE_LENGTH = 4;
  	private static final String[] BAD_SEQUENCES = {
  		"abcdefghijklmnopqrstuvwxyz", "qwertyuiop", "asdfghjkl", "zxcvbnm", "0123456789"
  	};
  	private static final String SPECIAL_CHAR_REGEX = ".*[!@#$%^&*()_+\\-={}|\\[\\]:\";'<>?,./`~].*";
  	private static final String[] COMPLEXITY_PATTERNS = {
  		".*[A-Z].*",           // 대문자
  		".*[a-z].*",           // 소문자
  		".*[0-9].*",           // 숫자
  		SPECIAL_CHAR_REGEX     // 특수문자
  	};

  	private final String value;

  	public static Password fromRaw(String raw) {
  		Password password = new Password(raw);

  		password.validate();

  		return password;
  	}

  	// 비밀번호 맞는지 확인
  	public void validate() {
  		if (StringUtils.isBlank(value) || value.length() < MIN_PASSWORD_LENGTH) {
  			throw new PasswordTooShortException();
  		}

  		long typeCount = Arrays.stream(COMPLEXITY_PATTERNS)
  			.filter(value::matches)
  			.count();

  		if (typeCount < MIN_PASSWORD_COMPLEXITY) {
  			throw new PasswordTooSimpleException();
  		}

  		checkBadSequence(value.toLowerCase());
  	}

  	private void checkBadSequence(String lowerPassword) {
  		for (String seq : BAD_SEQUENCES) {
  			for (int i = 0; i <= seq.length() - BAD_SEQUENCE_LENGTH; i++) {
  				String subSeq = seq.substring(i, i + BAD_SEQUENCE_LENGTH);
  				if (lowerPassword.contains(subSeq)) {
  					throw new PasswordHasSequenceException();
  				}
  			}
  		}
  	}

  	// 비밀번호 동일한지 확인하는 메서드
  	public void matches(BCryptPasswordEncoder encoder, String storedPassword) {
  		if (!encoder.matches(value, storedPassword)) {
  			throw new InvalidPasswordException();
  		}
  	}

  	// 비밀번호 변경 시 이전 비밀번호와 같은지 비교 (같다면 예외)
  	public void checkSameAs(BCryptPasswordEncoder encoder, String storedPassword) {
  		if (encoder.matches(value, storedPassword)) {
  			throw new SameAsPreviousPasswordException();
  		}
  	}
  }

  ```

### 2. `ImageUploader` util 클래스를 `ImageUploadService` 로 변경

- `file - service`
- 해당 클래스는 s3를 호출하고 이미지를 업로드 하는 기능을 수행함.
  하지만 util 클래스는 순수하고 의존성 없이 동작해야함.
  그래서 util 클래스의 기준에 부합하지 않아서 service 계층으로 작성

### 3. User 정보 uuid 대신 userId 기반으로 조회하도록 변경

- UUID는 외부 노출 및 식별 용도로 사용되며, 변경 가능성이 존재
- 인증 후 내부 처리에서는 불변의 식별자인 userId(PK)를 기준으로 조회하도록 리팩토링
  ```java
  @RequiredArgsConstructor
  @Service
  public class CurrentUserProvider {
  	private final UserProvider userProvider;

  	public User getUserFromUserId() {
  		return userProvider.getUserById(
  			Long.parseLong(SecurityContextHolder.getContext().getAuthentication().getName()));
  	}
  }
  ```
