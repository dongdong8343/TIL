@Conditional이 어떻게 동작하는지 학습 테스트를 만들어 봤다.

@Conditional을 사용할 때는 Condition 인터페이스가 구현된 클래스를 넣어줘야한다.

그리고 Condition 인터페이스의 mathces 메서드를 구현하고 메서드에서 던지는 boolean 값에 따라 빈이 만들어질지 안만들어질지 결정이 된다.

아래 코드처럼 메타 애노테이션을 만들어서 value 속성을 가질 수 있게 만들고 실제 클래스에 적용할 때 true, false 값을 넣어줘서 boolean 값에 따라 빈 생성 여부를 결정할 수 있다.

메타 애노테이션에 있는 value 값은 Condition을 구현한 클래스의 matches 메서드에서 metadata를 통해 접근할 수 있다.

```java
public class ConditionalTest {
	@Test
	void conditional() {
		// true
		ApplicationContextRunner contextRunner = new ApplicationContextRunner();
		contextRunner.withUserConfiguration(Config1.class)
			.run(context -> {
				assertThat(context).hasSingleBean(MyBean.class);
				assertThat(context).hasSingleBean(Config1.class);
			});

		// false
		new ApplicationContextRunner().withUserConfiguration(Config2.class)
			.run(context -> {
				assertThat(context).doesNotHaveBean(MyBean.class);
				assertThat(context).doesNotHaveBean(Config2.class);
			});

	}

	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.TYPE)
	@Conditional(BooleanCondition.class)
	@interface BooleanConditional {
		boolean value();
	}

	@Configuration
	@BooleanConditional(true)
	static class Config1 {
		@Bean
		MyBean myBean() {
			return new MyBean();
		}
	}

	@Configuration
	@BooleanConditional(false)
	static class Config2 {
		@Bean
		MyBean myBean() {
			return new MyBean();
		}
	}

	static class MyBean {

	}

	private static class BooleanCondition implements Condition {
		@Override
		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
			Map<String, Object> annotationAttributes = metadata.getAnnotationAttributes(
				BooleanConditional.class.getName());

			return (Boolean)annotationAttributes.get("value");
		}
	}
}
```
