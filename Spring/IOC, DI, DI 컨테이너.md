### IOC

기존에 코드를 작성할 때는 아래 작성된 코드처럼 직접 객체를 만들어서 관계를 설정하고 연결해주는 작업을 했었다.

```java
class MemberController() {
    private MemberService memberService = new MemberService();
}
```

하지만 IOC의 개념은 이와는 다른 개념이다. 외부(스프링 컨테이너)에서 객체를 생성해서 객체의 참조값을 클라이언트 측에 넘겨줌으로써 연결이 된다.

스프링 컨테이너에서 객체의 생명 주기를 관리하고 의존 관계를 연결해주는 역할을 한다.

이렇게 제어권이 외부로 넘어가서 제어의 역전이라고 부른다.
</br>
</br>
</br>

**- 그렇다면 ioc가 왜 필요할까?**

위 코드처럼 직접 클래스에서 객체를 생성해서 주입하는 경우 강한 결합을 가지게된다. 만약 MemberService가 아니라 다른 Serivice 객체로 변경하고 싶다면 MemberController 클래스를 수정해줘야한다.

그러나 ioc 덕분에 의존을 위한 객체를 개발자가 직접 생성하지 않아도 ioc 컨테이너가 이 역할을 대신 해준다. 그래서 유지보수성도 올라가고 코드의 양도 줄어들게 된다.

</br></br></br>
**- 프레임워크와 라이브러리**

IOC에 대해서 배웠으니 프레임워크와 라이브러리에 대한 차이도 알아보자.

프레임워크는 프레임워크 자체가 제어 흐름을 제어하고 우리는 흐름에 필요한 로직을 작성하면 콜을 하는 식으로 불러서 사용될 뿐이다.

라이브러리는 우리가 작성하는 흐름에서 필요할 때 가져다가 사용하는 것이다.

</br></br></br>

### DI

이번에는 의존관계 주입에 대해서 알아보자.

의존관계 주입은 A라는 클래스가 있고 이 A 클래스는 B 클래스를 구현한 객체를 필요로 한다고 가정해보자. 그럼 이 때 우리는 B 클래스를 구현해서 A 클래스의 필드에 넣어줘야 한다.

이를 의존관계 주입이라고 한다.

잠깐 정적인 클래스 의존 관계와 동적인 인스턴스 의존 관계에 대해서 설명해보겠다.

정적인 클래스 의존 관계는 기존의 코드(import), 다이어그램 상에 나오는 것을 바탕으로 어떤 클래스를 의존하고 있는지 판단이 가능하다.

그에 반해 동적인 인스턴스 의존 관계는 런타임 시 객체가 생성되고 객체가 해당 필드에 들어갈 때 어떤 객체를 의존하고 있는지 알 수 있다.

그러니까 실행 시점에 객체가 외부에서 생성이 돼서 참조값을 클라이언트에 전달해주면 연결이 되는 것이다.

```java
class MemberController() {
    private final MemberService memberService;

    public MemberController(MemberService memberService) {
        this.memberService = memberService;
    }

    public void func() {
        memberService.func1();
    }
}
```

의존관계 주입을 사용하면 동적인 인스턴스 의존 관계만 변경해서 의존 관계를 변경할 수 있다. 정적인 클래스 의존관계는 수정할 필요가 없다.

DI를 통해 각 객체의 역할에 대한 책임을 구분하고 각 객체가 서로 협력해서 프로그램 동작을 수행하도록 할 수 있다. 그리고 유지보수성과 확정성을 높일 수 있다.

위 코드를 보면 실제 MemberService 타입을 구현한 객체를 모르더라도 Controller 자신의 역할을 수행할 수 있다.
따라서 Service 객체를 변경하더라도 Controller 클래스의 코드는 수정할 필요가 없고 유지보수성과 확장성을 높일 수 있다.
</br>
</br>
</br>

### DI 컨테이너, IOC 컨테이너

객체의 생명 주기를 관리하고 의존 관계를 주입해주는 역할을 한다.
