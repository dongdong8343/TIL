## 컬렉션 프레임웍

다양한 종류의 컬렉션 클래스들을 표준화 된 방식으로 다룰 수 있게 해준다.

이는 재사용성과 사용에 편리함을 제공해준다는 장점이 있다.

## 핵심 인터페이스

핵심 인터페이스로는 List, Set, Map이 존재한다.

List는 순서가 중요하고 중복된 애들을 저장할 수 있다.

Set은 순서가 없고 중복된 애들을 저장할 수 없다.

Map은 키, 값으로 이루어진 요소를 중복없이 저장한다. 키는 중복이 되면 안되고 값은 중복돼도 상관없다.

## Collection 인터페이스

컬렉션 클래스에 저장된 데이터를 저장하고, 읽고, 추가하고, 삭제하는 등 컬렉션을 다루는데 필요한 메서드들을 제공한다.

필요하면 찾아보자.

## List 인터페이스

List는 위에서 말한 것 처럼 순서있고 중복된 애들을 저장할 수 있다는 특징이 있다.

Collection 인터페이스에서 상속받은 메서드를 제외하고 추가로 존재하는 메서드들이 있다.

## Set 인터페이스

중복허용하지 않고 저장 순서 없는 컬렉션 클래스를 구현하는데 사용된다.

대표적인 클래스로는 HashSet, TreeSet이 있다.

## Map 인터페이스

키와 값으로 이루어진 데이터를 순서 상관없이 저장하는 클래스를 구현하는데 사용된다.

대표적으로는 HashMap, LinkedHashMap, TreeMap 등이 있다.

### Map.Entry 인터페이스

Map 내부에 키와 값을 저장하기 위해 Map.Entry라는 내부 인터페이스가 존재한다.

이는 키와 값을 따로 저장하기 보다는 연관된 데이터이기 때문에 하나로 묶는 것이 더 낫다.

```java
public interface Map {
    public interface Entry {
        K getKey();
        V getValue();
        V setValue(Object value);
        boolean equals(Object o);
        int hashCode();
        ...
    }
}
```

## ArrayList

ArrayList는 Vector를 개선한 것이다. 내부적으로는 배열로 데이터를 저장한다.

그래서 데이터를 저장하다가 저장 가능 범위를 벗어나면 새로운 배열을 만들어서 값을 복사한 후 이어서 데이터를 저장하는 방식으로 이루어진다.

```java
transient Object[] elementData; // 실제 데이터를 저장하는 배열
```

추가로 어떤 요소를 삭제할 때 순회하면서 해당 데이터가 존재하면 삭제를 하도록 구현할 것이다.

이 때 맨 앞에서부터 탐색을 시작해서 요소를 찾았다고 가정하자. 그럼 그 데이터를 삭제하고 뒤에 있는 데이터들을 앞으로 복사할 것이다. 이렇게 옮기고 순회를 이어간다면 뒤에 탐색할 데이터가 앞으로 이동했기 때문에 결과에 영향을 끼칠 수 있다.

그래서 뒤에서부터 탐색을 진행하고 삭제하는 것이 바람직하다.

```java
import java.util.*;

public class RemoveFromEnd {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>(Arrays.asList(1,2,3,2,4,2,5));

        int target = 2;
        for (int i = list.size() - 1; i >= 0; i--) {
            if (list.get(i) == target) {
                list.remove(i);                // 뒤에서 앞으로면 인덱스 밀림 영향 없음
            }
        }
        System.out.println(list); // [1, 3, 4, 5]
    }
}
```

## LinkedList

LinkedList는 내부를 배열로 구현한 것이 아니라 다음 요소를 참조하도록 구현이 되어있다.

그래서 데이터를 저장할 때 저장 공간이 부족해서 값을 복사하는 일이 없다. 즉 저장할 때 시간 낭비하는 일이 없다는 의미다.

그리고 삭제를 할 때도 참조만 변경해주면 된다는 편리함이 있다.

참고로 LinkedList는 더블 링크드 리스트로 구현이 되어있다. 양방향으로 접근해서 단방향보다 효율이 좋다는 특징을 가지고 있다.

그럼 LinkedList와 ArrayList의 차이를 비교해보자.

순차적인 데이터를 저장, 삭제할 때는 ArrayList가 빠르다.

하지만 중간에 요소를 저장하거나 삭제할 때는 LinkedList가 더 빠르다는 특징이 있다. (ArrayList로 이걸 구현하면 값들을 막 복사하는 작업이 필요해서 효율이 떨어진다.)

## Iterator

컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator 인터페이스를 정의하고 Collection 인터페이스에는 Iterator를 반환하는 iterator()를 정의하고 있다.

```java
Collection c = new ArrayList();
Iterator it = c.iterator();

while(it.hasNext()){
    System.out.println(it.next());
}
```

위와 같은 코드가 있다고 했을 때 컬렉션의 요소를 iterator를 통해서 쉽게 순회할 수 있다.

그리고 ArrayList의 인스턴스를 Collection으로 받은 이유는 나중에 컬렉션 구현체가 변경이 될 때 저 코드만 변경해주면 되기 때문에 유지보수성이 올라가게된다.

## Arrays

배열을 다루는데 유용한 메서드들이 집합해있다.

### 배열의 복사

- copyOf(), copyOfRange()

```java
import java.util.Arrays;

public class CopyOfExample {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};

        // 원본 크기만큼 복사
        int[] copy1 = Arrays.copyOf(arr, arr.length);
        System.out.println(Arrays.toString(copy1)); // [1, 2, 3, 4, 5]

        // 길이를 늘려서 복사 (기본값 0으로 채워짐)
        int[] copy2 = Arrays.copyOf(arr, 8);
        System.out.println(Arrays.toString(copy2)); // [1, 2, 3, 4, 5, 0, 0, 0]

        // 길이를 줄여서 복사
        int[] copy3 = Arrays.copyOf(arr, 3);
        System.out.println(Arrays.toString(copy3)); // [1, 2, 3]
    }
}

```

```java
import java.util.Arrays;

public class CopyOfRangeExample {
    public static void main(String[] args) {
        int[] arr = {10, 20, 30, 40, 50};

        // index 1부터 4까지 복사 (4는 제외)
        int[] subArr = Arrays.copyOfRange(arr, 1, 4);
        System.out.println(Arrays.toString(subArr)); // [20, 30, 40]

        // endIndex가 배열 길이보다 크면 남는 부분 0으로 채움
        int[] extended = Arrays.copyOfRange(arr, 2, 7);
        System.out.println(Arrays.toString(extended)); // [30, 40, 50, 0, 0]
    }
}
```

### 배열 채우기 - fill(), setAll();

### 배열 정렬, 검사 - sort(), binarySearch()

binarySearch 같은 경우는 정렬된 요소들 중 데이터를 찾을 때 빠르게 찾을 수 있다는 특징이있다.

### 배열의 비교 - equals()

모든 요소를 비교해서 동일하면 ture를 다르면 false를 반환한다.

## Comparator, Comparable

음수, 0, 양수를 반환하고 해당하는 값에 따라 정렬이 되는 방식이다.

Comparable은 기본 정렬기준을 구현하는데 사용하고 자기 자신과 비교한다.

Comparator는 다른 기준으로 정렬하고자 할 때 사용한다.

## HashSet

HashSet은 중복된 요소는 저장안한다. 중복된 요소를 저장하려고 하면 false를 반환해서 추가가 안된다.

만약 중복 제거와 동시에 순서를 보장하고 싶다면 LinkedHashSet을 사용하면 된다.

## TreeSet

이진 검색 트리라는 자료구조의 형태로 데이터를 저장하는 컬렉션 클래스다.

중복된 데이터의 저장을 허용안한다. 그리고 정렬된 위치에 저장해서 저장순서를 유지하지않는다.

## TreeMap

이진 검색 트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장한다.

검색과 정렬에 적합한 컬렉션 클래스다.

단 검색에 관한 대부분의 경우는 HashMap이 더 뛰어난 경우가 많다. 하지만 범위검색이나 정렬이 필요한 경우는 TreeMap이 더 뛰어나다.

## Collections

Collections는 컬렉션과 관련된 메서드를 제공한다.

### 컬렉션의 동기화

멀티쓰레드 환경에서는 여러 쓰레드가 동시에 하나의 객체에 접근할 수 있다.

그래서 데이터의 일관성을 유지하기위해서는 동기화가 필요하다.

Collections 클래스에서는 다음과 같이 동기화 메서드를 제공하고 있다.

```java
List<T> syncList = Collections.synchronizedList(new ArrayList<>());
Set<T> syncSet = Collections.synchronizedSet(new HashSet<>());
Map<K,V> syncMap = Collections.synchronizedMap(new HashMap<>());
SortedMap<K,V> syncSortedMap = Collections.synchronizedSortedMap(new TreeMap<>());
SortedSet<T> syncSortedSet = Collections.synchronizedSortedSet(new TreeSet<>());
```

### 변경불가 컬렉션 만들기

읽기 전용으로 컬렉션을 만드는 경우가 있는데 아래와 같은 메서드를 통해 만들 수 있다.

```java
static <T> Set<T> Collections.unmodifiableSet(Set<? extends T> s)
static <T> List<T> Collections.unmodifiableList(List<? extends T> list)
static <K,V> Map<K,V> Collections.unmodifiableMap(Map<? extends K, ? extends V> m)
static <T> SortedSet<T> Collections.unmodifiableSortedSet(SortedSet<T> s)
static <K,V> SortedMap<K,V> Collections.unmodifiableSortedMap(SortedMap<K, ? extends V> m)

// 사용 예
Set<String> readOnly = Collections.unmodifiableSet(new HashSet<>(Set.of("A","B")));
```

이 외에도 싱글톤 컬렉션 만들기, 한 종류의 객체만 저장하는 컬렉션 만들기도 가능하다.
