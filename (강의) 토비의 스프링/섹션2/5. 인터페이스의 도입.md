- 앞에서 클래스로 알아서 분리하라고 하면 메서드 명이 자기 입맛대로 바뀐 것을 봤을 것이다.

- 이렇게되면 코드의 변경이 잦아서 비효율적이다.

- 그럼 인터페이스를 도입해서 메서드 명을 하나로 통일 시켜보자.

```java
public interface ExRateProvider {
	BigDecimal getExRate(String currency) throws IOException;
}
```

```java
public class PaymentService {

	private final ExRateProvider exRateProvider;

	public PaymentService() {
		this.exRateProvider = new WebApiExRateProvider();
	}

	public Payment prepare(Long orderId, String currency, BigDecimal foreignCurrencyAmount) throws
		IOException {

		BigDecimal exRate = exRateProvider.getExRate(currency);

		BigDecimal convertedAmount = foreignCurrencyAmount.multiply(exRate);
		LocalDateTime validUntil = LocalDateTime.now().plusMinutes(30);

		return new Payment(orderId, currency, foreignCurrencyAmount, exRate, convertedAmount, validUntil);
	}
}
```

```java
public class WebApiExRateProvider implements ExRateProvider {
	@Override
	public BigDecimal getExRate(String currency) throws IOException {
		URL url = new URL("https://open.er-api.com/v6/latest/" + currency);
		HttpURLConnection connection = (HttpURLConnection)url.openConnection();
		BufferedReader br = new BufferedReader(
			new InputStreamReader(connection.getInputStream()));
		String response = br.lines().collect(Collectors.joining());
		br.close();

		ObjectMapper mapper = new ObjectMapper();
		ExRateData data = mapper.readValue(response, ExRateData.class);
		return data.rates().get("KRW");
	}
}

```

```java
public class SimpleExRateProvider implements ExRateProvider{
	@Override
	public BigDecimal getExRate(String currency) throws IOException {
		if(currency.equals("USD"))
			return BigDecimal.valueOf(1000);

		throw new IllegalArgumentException("지원되지 않는 통화입니다.");
	}
}
```

- 하지만 여기서도 여전히 문제가 있다.

- 메서드 명을 통일시켜줬지만 새로운 Provider 클래스를 만들 때마다 Service 클래스 내부에 Provider 객체를 주입하는 곳의 코드는 변경해줘야 한다는 단점이 있다.

- 이 문제를 해결하는 방법은 다음 파일에 작성한다.
