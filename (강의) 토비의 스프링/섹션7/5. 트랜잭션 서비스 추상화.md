이번에는 JPA TransactionManager에 의존하는 것을 해결할 것이다.

트랜잭션은 데이터 기술에 따라 방법이 다르기 때문이다.

만약 JPA가 아닌 JDBC와 같은 기술로 변경하면 기존의 Service 코드의 변경이 일어난다는 문제가 발생한다. 그래서 추상화 작업을 진행할 것이다.

### 추상화

구체적인 것들에서 중요한 것만 남기는 작업을 말한다.

여러 인프라 서비스 기술의 공통적이고 핵심적인 기능만 인터페이스로 구현하고 세세한 구현은 어댑터를 만들어서 일관된 사용이 가능하도록 만드는 것이다.

중간에 변환하는 작업을 위해 어댑터를 두는 것이다. 스프링이 기술별로 어댑터를 제공해준다.

<center>
      <img
          src="https://github.com/user-attachments/assets/9d7088d5-e373-43cf-b9f0-9baba9a7e870"
          width="100%"
      />
</center>

### JDBC 데이터 엑세스 기술

기존의 JPA를 사용하던 것을 JDBC로 변경을 진행해본다.

변경할 사항은 아래와 같다.

- JDBCClient

  - spring 6.1에서 추가
  - SQL을 사용하는 JDBC 데이터 처리 코드를 유연하게 도와준다.
  - 일종의 템플릿/콜백으로 기존의 JdbcTemplate보다 모던하게 사용할 수 있게 도와준다.

- DataSourceTransactionManager

  - JDBC의 Connection을 이용하는 트랜잭션 매니저
  - Connection을 리턴하는 DataSource 오브젝트가 필요하다.

OrderService는 OrderRepository를 의존하고 있다. 그리고 생성자를 통해서 Repository를 넣어줄 때 jpa를 사용하는 Repository에 넣어줬었다. 하지만 이번에는 JDBC를 사용하는 Repository를 넣어줄 것이다.

서비스는 Repository의 인터페이스를 의존하고 있기 때문에 JDBC를 사용하는 Repository를 의존한다고해서 기존의 서비스 코드는 변경할 일이 없다.

1. JdbcOrderRepository 만들기

   ```java
   public class JdbcOrderRepository implements OrderRepository {
       private final JdbcClient jdbcClient;

       public JdbcOrderRepository(DataSource dataSource) {
           this.jdbcClient = JdbcClient.create(dataSource);
       }

       // JdbcOrderRepository 빈이 생성되면 여기서 테이블 생성
       @PostConstruct
       void initDb() {
           jdbcClient.sql("""
                   create table orders (id bigint not null, no varchar(255), total numeric(38,2), primary key (id));
               alter table if exists orders drop constraint if exists UK_43egxxciqr9ncgmxbdx2avi8n;
               alter table if exists orders add constraint UK_43egxxciqr9ncgmxbdx2avi8n unique (no);
               create sequence orders_SEQ start with 1 increment by 50;
               """).update();
       }

       @Override
       public void save(Order order) {
           // Jpa는 시퀀스을 알아서 들고왔지만 Jdbc는 직접 가지과 와줘야 함.
           Long id = jdbcClient.sql("select next value for orders_SEQ").query(Long.class).single();

           order.setId(id);

           jdbcClient.sql("insert into orders (no, total, id) values (?,?,?)")
               .params(order.getNo(), order.getTotal(), order.getId()).update();
       }
   }

   ```

2. DataConfig 수정

```java
@Configuration
public class DataConfig {
	// data source
	@Bean
	public DataSource dataSource() {
		return new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2).build();
	}

	@Bean
	public PlatformTransactionManager transactionManager() {
		// Jdbc 전용 트랜잭션 매니저
		return new DataSourceTransactionManager(dataSource());
	}
}

```

3. OrderConfig 구성 정보 변경

   ```java
   @Configuration
   @Import(DataConfig.class)
   public class OrderConfig {
       @Bean
       public OrderService orderService(PlatformTransactionManager transactionManager, OrderRepository orderRepository) {
           return new OrderService(orderRepository, transactionManager);
       }

       @Bean
       public OrderRepository orderRepository(DataSource dataSource) {
           return new JdbcOrderRepository(dataSource);
       }
   }
   ```

- 특정 기술의 구현체를 코드에 적용할 때 공통적으로 제공하는 액션이 같다면 서비스의 추상화를 활용해보자. 그럼 나중에 다른 구현체로 변경해도 기존의 코드가 수정될 일은 없다.
