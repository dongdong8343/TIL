기존에 작성된 코드를 보면 SpringBoot가 처음에 제공하는 코드와 조금 다른 점이 있다.

```java
@Configuration
@ComponentScan
public class TobySpringbootApplication {

	@Bean
	public ServletWebServerFactory servletWebServerFactory() {
		return new TomcatServletWebServerFactory();
	}

	@Bean
	public DispatcherServlet dispatcherServlet() {
		return new DispatcherServlet();
	}

	public static void main(String[] args) {
		SpringApplication.run(TobySpringbootApplication.class, args);
	}
}
```

애노테이션이 2개나 사용되고 있고 빈을 등록하는 코드도 작성이 돼있다.

일단 애노테이션을 하나의 애노테이션으로 만들 것이다. 그것은 바로 합성 애노테이션을 사용하면 만들 수 있다.

그래서 일단 합성 애노테이션을 만든다.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE) // class, interface, enum에 적용
@Configuration
@ComponentScan
public @interface MySpringBootAnnotation {

}
```

그리고 합성 애노테이션을 적용해준다.

```java
@MySpringBootAnnotation
public class TobySpringbootApplication {
	@Bean
	public ServletWebServerFactory servletWebServerFactory() {
		return new TomcatServletWebServerFactory();
	}

	@Bean
	public DispatcherServlet dispatcherServlet() {
		return new DispatcherServlet();
	}

	public static void main(String[] args) {
		SpringApplication.run(TobySpringbootApplication.class, args);
	}
}
```

이제 남은 건 빈을 등록하는 코드인데 이 코드들은 따로 Config 클래스를 만들어서 안에 넣을 것이다.

그리고 이 빈을 등록한다고 ComponentScan할 때 알려야하기 때문에 @Component를 붙이는 것이 좋을 것 같다.

하지만 설정 클래스라는 의미를 가지고있는 @Configuration을 사용할 것이다. 왜냐하면 이 애노테이션도 @Component를 포함하고 있기 때문이다.

```java
@Configuration
public class Config {
	@Bean
	public ServletWebServerFactory servletWebServerFactory() {
		return new TomcatServletWebServerFactory();
	}

	@Bean
	public DispatcherServlet dispatcherServlet() {
		return new DispatcherServlet();
	}

}

```
