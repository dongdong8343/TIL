- 스프링은 아래 원칙과 패턴을 통해 우리의 프로그램이 잘 동작할 수 있게 도와주고 프로그램을 객체 지향적으로 작성할 수 있게 도와준다.

- 개방 폐쇄 원칙 (Open-Closed Principle - OCP)

  - 확장에는 열려있고 변경에는 닫혀있어야한다는 원칙이다.

  - 말 그대로다. 어떠한 클래스를 만들어서 확장했는데 확장할 때마다 이와 관련된 코드가 매번 변경이 되면 매우 귀찮다.

    2-7의 파일을 보면 Service 쪽의 prepare()에서 환율 정보를 가져올 때 각 사람들마다 가져오는 방법이 다르다. 그래서 사람들마다 새로운 Provider 클래스를 만들어서 사용할 것이다.

    하지만 새로운 클래스가 만들어진다고 해서 Service 쪽의 코드가 변경이 되나? 그렇지 않다.

    이처럼 확장이 되더라도 변경이 일어나지 않는 것이 좋다.

- 높은 응집도와 낮은 결합도

  - 높은 응집도

    - 응집도가 높으면 코드를 수정할 때 해당 클래스만 수정하면 돼서 비용이 낮다. 반대로 응집도가 낮으면 어떤 기능을 수정한다고 했을 때 여러 부분을 손봐야 할 것이다...

  - 낮은 결합도

    - 느슨한 결합을 가져야 한 쪽에서 코드가 변경이 된다해도 연관된 한 쪽에서 변경될 일이 없을 것이다.

- 전략 패턴

  - Service 클래스를 보면 환율 정보를 가져오는 알고리즘이 사람마다 다른 것을 확인할 수 있다.

    사람들 입맛대로 Provider 인터페이스를 구현해서 Service 클래스에 넘겨주는 것을 볼 수 있다.

    이처럼 자신의 기능 맥락에서 변경이 되는 알고리즘 부분을 인터페이스를 통해 분리시키고 이 인터페이스를 구현한 클래스에 따라 동작이 달라지는 패턴을 말한다.

    ```java
    public class PaymentService {

        private final ExRateProvider exRateProvider;

        // 필요한 전략을 생성자를 통해 주입 받아서 사용됨.
        // Provider는 전략이 된다.
        public PaymentService(ExRateProvider exRateProvider) {
            this.exRateProvider = exRateProvider;
        }

        public Payment prepare(Long orderId, String currency, BigDecimal foreignCurrencyAmount) throws
            IOException {

            BigDecimal exRate = exRateProvider.getExRate(currency);

            BigDecimal convertedAmount = foreignCurrencyAmount.multiply(exRate);
            LocalDateTime validUntil = LocalDateTime.now().plusMinutes(30);

            return new Payment(orderId, currency, foreignCurrencyAmount, exRate, convertedAmount, validUntil);
        }
    }
    ```

- 제어의 역전 (Inversion of Control - IoC)

  - 앞에서 오브젝트 팩토리를 통해서 의존 관계를 설정해주는 것을 봤을 것이다. 이처럼 관계설정 책임을 외부에서 설정해주는 것을 제어의 역전이라고 한다.

    일단은 내가 하던 권한이 다른 쪽으로 권한이 넘어갔다고 이해하고 넘어가자.
