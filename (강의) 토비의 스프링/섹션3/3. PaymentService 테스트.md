- 기존에 PaymentService를 테스트하기 위해서 그대로 prepare 메서드를 사용해서 잘 동작하는지 확인을 했었다.

  하지만 이렇게 하면 외부에서 환율을 가져오는 곳에 문제가 발생하면 Service에 영향을 끼치게 되고 테스트가 제대로 동작하지 않을 것이다.

- 테스트의 구성 요소는 아래와 같이 이뤄진다.

    <center>
      <img
          src="https://github.com/user-attachments/assets/92ce232a-c261-47f3-8df2-2c0c285e78af"
          width="100%"
      />
    </center>

  협력자가 관여해서 테스트 대상을 테스트한다. 하지만 협력자의 동작을 아직 테스트 하지 않은 상황에서 테스트 대상을 테스트하는데 제대로 테스트 했다고 말할 수 있을까?

  그래서 Stub이란걸 둔다. 테스트 하는 동안만 임시 협력자가 되는 것이다.

    <center>
      <img
          src="https://github.com/user-attachments/assets/80b62ae6-e766-4568-9f1a-42df0bc00c46"
          width="100%"
      />
    </center>

- 위와 같이 Stub이라는 협력자를 만들었을 때 테스트 하는 방법은 아래와 같다.

  1. 수동 DI를 이용하는 테스트

     말그대로 새로운 Stub를 만들었을 때 수동으로 의존성 주입을 해서 테스트 하는 방식이다.

     그리고 testAmount를 여러 번 호출하는 것을 확인할 수 있다. 그 이유는 한 번만 확인했을 경우 우연히 통과하는 경우도 있기 때문에 여러 번 확인하는 것이다.

     ```java
     class PaymentServiceTest {

         @Test
         @DisplayName("prepare 메서드가 요구사항 3가지를 잘 충족했는지 검증")
         void convertedAmount() throws IOException {
             testAmount(valueOf(500), valueOf(5_000));
             testAmount(valueOf(1_000), valueOf(10_000));
             testAmount(valueOf(3_000), valueOf(30_000));
     }

         private static void testAmount(BigDecimal exRate, BigDecimal convertedAmount) throws IOException {
             // 준비 -> ExRateProviderStub를 통해 외부의 영향을 받지 않고 순수하게 Service만 검증 가능
             PaymentService paymentService = new PaymentService(new ExRateProviderStub(exRate));

             // 실행
             Payment payment = paymentService.prepare(1L, "USD", BigDecimal.TEN);

             // 검증
             assertThat(payment.getExRate()).isEqualByComparingTo(exRate);
             assertThat(payment.getConvertedAmount()).isEqualByComparingTo(convertedAmount);
         }
     }






     public class ExRateProviderStub implements ExRateProvider {
         private BigDecimal exRate;

         public BigDecimal getExRate() {
             return exRate;
         }

         public void setExRate(BigDecimal exRate) {
             this.exRate = exRate;
         }

         public ExRateProviderStub(BigDecimal exRate) {
             this.exRate = exRate;
         }

         @Override
         public BigDecimal getExRate(String currency) throws IOException {
             return this.exRate;
         }
     }
     ```

  2. 스프링 DI를 이용한 테스트

     - 협력자가 많은 경우 사용하면 편리하다.

     - 테스트용 협력자/의존 오브젝트를 스프링의 구성 정보를 이용해 지정하고 컨테이너로부터 테스트 대상을 가져와서 테스트하는 방식이다.

     - 의존관계를 자동으로 주입해주기 때문에 의존성이 추가된다고 하더라도 기존의 테스트 코드를 수정할 필요가 없다.

     - @ContextConfiguration(classes = TestObjectFactory.class)

       테스트 실행 시 어떤 구성 정보를 가지고 빈을 등록할 것인지 지정하는 어노테이션이다.

     ```java
     @ExtendWith(SpringExtension.class)
     @ContextConfiguration(classes = TestObjectFactory.class)
     class PaymentServiceSpringTest {

         @Autowired
         PaymentService paymentService;

         @Test
         @DisplayName("prepare 메서드가 요구사항 3가지를 잘 충족했는지 검증")
         void convertedAmount() throws IOException {
             Payment payment = paymentService.prepare(100L, "USD", TEN);

             assertThat(payment.getExRate()).isEqualByComparingTo(valueOf(1_000));
             assertThat(payment.getConvertedAmount()).isEqualByComparingTo(valueOf(10_000));
         }
     }





     // 테스트에서만 사용할 ObjectFactory
     // 기존의 것을 사용하면 실제 프로그램 동작할 때 테스트에서 사용된게 동작할 수도 있다. 그래서 test용을 만드는거다.
     @Configuration
     public class TestObjectFactory {
         @Bean
         public PaymentService paymentService() {
             return new PaymentService(exRateProvider());
         }

         @Bean
         public ExRateProvider exRateProvider() {
             return new ExRateProviderStub(valueOf(1_000));
         }
     }

     ```
