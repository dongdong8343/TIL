이번에는 어떤 라이브러리가 이 프로젝트에 현재 포함되어 있는지 체크하고 tomcat을 띄울지 jetty를 띄울지 결정한다.

기존에는 Condition 인터페이스를 구현한 클래스의 matches 메서드를 통해 true, false 라는 값을 직접줘서 구성 클래스를 포함시킬지 말지를 결정했다.

어떤 라이브러리가 이 프로젝트에 있는지 체크하는 것은 간단하다. 이 체크하는 로직은 Tomcat과 Jetty를 구성하는 구성 클래스 모두에 적용이 되기 때문에 하나의 메타 에노테이션과 하나의 Condition 인터페이스를 구현한 클래스를 만들 것이다.

1. 메타 애노테이션 만들기

   ```java
   @Retention(RetentionPolicy.RUNTIME)
   @Target({ElementType.TYPE, ElementType.METHOD})
   @Conditional(MyOnClassCondition.class)
   public @interface ConditionalMyOnClass {
   	String value();
   }
   ```

2. Condition 인터페이스를 구현하는 클래스 생성

   metadata를 통해 메타 애노테이션을 적용할 때 작성한 Tomcat과, Jetty 클래스의 풀네임을 보고 실제 라이브러리로 존재하는지 파악한다.

   파악 후 있다면 true를 없다면 false를 던지는 그런 구조로 되어있다.

   ```java
   public class MyOnClassCondition implements Condition {
   	@Override
   	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
   		Map<String, Object> annotationAttributes = metadata.getAnnotationAttributes(
   			ConditionalMyOnClass.class.getName());
   		String value = (String)annotationAttributes.get("value");
   		return ClassUtils.isPresent(value, context.getClassLoader());
   	}
   }
   ```

3. 만든 메타 애노테이션을 구성 클래스에 적용

   ```java
   @MyAutoConfiguration
   @ConditionalMyOnClass("org.apache.catalina.startup.Tomcat")
   public class TomcatWebServerConfig {
   	@Bean("tomcatWebServerFactory")
   	public ServletWebServerFactory servletWebServerFactory() {
   		return new TomcatServletWebServerFactory();
   	}
   }
   ```

   ```java
   @MyAutoConfiguration
   @ConditionalMyOnClass("org.eclipse.jetty.server.Server")
   public class JettyWebServerConfig {
   	@Bean("jettyWebServerFactory")
   	public ServletWebServerFactory servletWebServerFactory() {
   		return new JettyServletWebServerFactory( );
   	}
   }
   ```

여기까지하면 라이브러리에 포함된 서버에 따라 애플리케이션이 동작하게 된다.

정리를 하자면 아래와 같은 구조가 나오게 되는 것이다.

<center>
  <img
    src="https://github.com/user-attachments/assets/bfd7a0db-737e-4911-adc0-bfc522a257a0"
    width="50%"
  />
</center>
