지금 OrderService는 바로 JpaOrderRepository를 의존하고 있다.

그렇게되면 DB에 접근하는 기술을 JPA가 아닌 다른 기술을 사용하게 되면 OrderService에 영향을 끼칠 수 있다는 우려가 있다.

사실 JPA를 쓴다고 못박아두고 개발하는 경우도 많다고 한다.

그래서 이어서 말해보자면 OrderService와 JpaOrderRepository 모두 인터페이스에 의존하도록 변경한다.

<center>
      <img
          src="https://github.com/user-attachments/assets/ca0b5bfe-6583-4f38-8fe2-d186db5a7a6d"
          width="100%"
      />
</center>

1. OrderRepository라는 인터페이스 생성

   의존역전원칙에 따라 상위 모듈은 하위 모듈에 의존하면 안된다. 그렇기 때문에 OrderRepository를 만들 때 Service가 있는 패키지에 위치시켰다.

   ```java
   public interface OrderRepository {
       void save(Order order);
   }
   ```

2. OrderRepository를 구현한 클래스 생성

   ```java
   public class JpaOrderRepository implements OrderRepository {
       @PersistenceContext
       private EntityManager em; // 트랜잭션마다 새롭게 만들어진다.

       @Override
       public void save(Order order) {
           em.persist(order);
       }
   }

   ```

3. OrderService에서 인터페이스인 OrderRepository를 의존하도록 변경

   ```java
   @Service
   public class OrderService {
       private final OrderRepository orderRepository;
       private final JpaTransactionManager jpaTransactionManager;

       public OrderService(OrderRepository orderRepository, JpaTransactionManager jpaTransactionManager) {
           this.orderRepository = orderRepository;
           this.jpaTransactionManager = jpaTransactionManager;
       }

       public Order createOrder(String no, BigDecimal total) {
           Order order = new Order(no, total);

           return new TransactionTemplate(jpaTransactionManager).execute(status -> {
               this.orderRepository.save(order);

               return order;
           });
       }
   }

   ```

   ```java
   @Configuration
   @Import(DataConfig.class)
   public class OrderConfig {
       @Bean
       public OrderService orderService(JpaTransactionManager transactionManager) {
           return new OrderService(orderRepository(), transactionManager);
       }

       @Bean
       public OrderRepository orderRepository() {
           return new JpaOrderRepository();
       }
   }
   ```

4. 테스트를 만들어서 잘 동작하는지 확인한다.

   ```java
   @ExtendWith(SpringExtension.class)
   @ContextConfiguration(classes = OrderConfig.class)
   public class OrderServiceSpringTest {
       @Autowired
       OrderService orderService;

       @Test
       void createOrder() {
           // 반환된 오브젝트가 뭔지 명확하면 var를 사용해도 괜찮다.
           var order = orderService.createOrder("0100", BigDecimal.TEN);

           Assertions.assertThat(order.getId()).isGreaterThan(0);
       }
   }
   ```
