## 객체지향언어

객체지향언어를 사용하는 이유는 뭘까??

1. 코드의 재사용성이 높다.
2. 코드의 관리가 용이하다.
3. 중복된 코드를 제거해서 일관성을 유지할 수 있다.

## 클래스와 객체

클래스 - 객체를 정의해놓은 객체의 틀이다.

객체 - 클래스를 통해 생성된 실체를 의미한다.

## 객체와 인스턴스

객체와 인스턴스는 비슷한 의미로 사용이 된다.

굳이 나누자면 아래와 같다.

객체 - 인스턴스의 대표 (포괄적인 의미)

인스턴스 - 클래스로부터 만들어지고 메모리에 올라가 실제 동작하는 객체

## 선언위치에 따른 변수의 종류

1. 클래스 변수

   - 클래스가 메모리에 올라갈 때 생성
   - 클래스이름.클래스변수 형태로 사용
     - 객체.클래스변수로 사용하면 클래스 변수가 아닌 인스턴스 변수로 착각할 수 있기때문

2. 인스턴스 변수

   인스턴스가 생성될 때 생성

3. 지역 변수

   변수 선언문이 수행됐을 때

## 변수의 초기화

멤버변수는 초기화를 하지 않아도 자동으로 기본값으로 초기화된다. 하지만 지역변수는 자동으로 초기화가 안되기때문에 반드시 초기화 해줘야한다.

### 초기화 방법

1.  명시적 초기화

    우리가 흔히 알고있는 방법이다.

    ```java
        int a = 43;
    ```

2.  생성자

    생성자를 통해서 변수들을 초기화하는 방법을 말한다.

3.  초기화 블럭

        초기화 블럭을 통해 초기화하는 방법은 조금 생소하다.

        {}을 통해서 초기화할 수 있다.

        - 인스턴스 초기화 블럭

            인스턴스 변수를 초기화하기 위함
        - 클래스 초기화 블럭

            클래스 변수를 초기화하기 위함

        ```java
        public class InitExample {

            static nt st
        public class InitExample {

    2
    statiiaticValue;

            // 클래스 초기화 블럭
            static {
                System.out.println("클래스 초기화 블럭 실행");
                staticValue = 100; // static 변수 초기화
            }

            int instanceValue;

            // 인스턴스 초기화 블럭
            {
                System.out.println("인스턴스 초기화 블럭 실행");
                instanceValue = 10; // 인스턴스 변수 초기화
            }

            // 생성자
            public InitExample() {
                System.out.println("생성자 실행");
            }

            public static void main(String[] args) {
                System.out.println("main 시작");

                System.out.println("첫 번째 객체 생성");
                InitExample obj1 = new InitExample();

                System.out.println("두 번째 객체 생성");
                InitExample obj2 = new InitExample();

                System.out.println("staticValue: " + InitExample.staticValue);
            }
        }
        ```

        실행 결과는 아래와 같다.

        생성자보다 인스턴스 초기화 블럭이 먼저 수행된다!

        ```
            클래스 초기화 블럭 실행
            main 시작
            첫 번째 객체 생성
            인스턴스 초기화 블럭 실행
            생성자 실행
            두 번째 객체 생성
            인스턴스 초기화 블럭 실행
            생성자 실행
            staticValue: 100
        ```

## JVM 메모리 구조

1. 메서드 영역

   - 클래스 정보, 클래스 변수가 올라감
   - 어떤 클래스가 사용되면 클래스 파일을 읽고 분석해 해당 정보를 저장

2. 힙 영역

   - 인스턴스가 올라감

3. 호출스택

   - 호출된 메서드를 위한 공간

## 클래스 메서드, 인스턴스 메서드

1. 클래스 메서드

   - 인스턴스들이 공통으로 사용 가능한 동작을 정의한 메서드
   - 인스턴스 메서드를 사용할 수 없다.

     클래스 메서드는 인스턴스를 생성하지않고 사용가능한데 여기서 인스턴스 메서드를 호출해서 사용한다는 것은 말이 안된다.

2. 인스턴스 메서드

   - 인스턴스 변수와 관련된 작업을 하기위한 메서드

## 오버로딩

객체지향에서 중요한 개념 중 하나인 오버로딩이다.

오버로딩은 매개변수의 타입, 순서를 다르게해서 동일한 이름으로 메서드를 선언하는 것을 말한다.

이렇게 하는 이유는 뭘까?

매개변수만 다르고 동작을 살펴보면 동일한 동작을 한다고 가정하자. 이럴때마다 매번 메서드의 이름을 다르게 짓는 것은 부담으로 다가올 수 있다.

하지만 오버로딩을 사용하면 이런 부담을 줄일 수 있다는 장점이 있다.

## 상속

기존의 클래스를 재사용해서 새로운 클래스를 작성하는 것을 말한다.

왜 상속을 활용하는 것일까? 그 이유는 재사용성, 코드의 중복 제거를 통한 유지보수성을 높이기 위함이다.

상속은 아래와 같이 extends 키워드를 사용한다.

```java
class Dog extends Animal {}
```

참고로 생성자, 초기화 블록은 상속이 안된다. 멤버만 상속된다.

자손 클래스의 멤버 수는 조상 클래스보다 많거나 같다. 왜냐하면 기존 멤버에서 멤버가 추가될 수 있기 때문이다.

그리고 private, default 멤버는 상속이 안된다고 알고 있었는데 상속이 안되는게 아니라 접근이 안되는 것이다.

아래와 같이 코드가 있다고 가정했을 때 중복되는 코드는 parent에 담아서 중복을 줄일 수 있다.

```java
class Parent {}

class Child extends Parent {}

class Child2 extends Parent {}
```

자손 클래스의 인스턴스를 생성하면 자손 클래스의 멤버와 조상 클래스의 멤버가 합쳐진 인스턴스가 생성이 된다.

추가로 자바에서는 다중 상속이 불가하다. 단일 상속만 된다.

## 오버라이딩

상속 받는 기능을 자손 클래스에 맞게 재정의 하는 것을 말한다.

### 오버라이딩의 조건

1. 선언부 동일
2. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 불가하다.

   ex) 조상클래스의 메서드가 public인데 자손 클래스의 메서드가 private이 될 수 없다는 뜻이다.

3. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.

## 접근제어자

**private**

같은 클래스내에서만 접근 가능

**default**

같은 패키지내에서만 접근 가능

**protected**

같은 패키지내에서만 접근 가능, 다른 패키지의 자손 클래스는 접근 가능

**public**

어느곳에서든 접근 가능

접근 제어자를 사용하는 이유는 내부 데이터를 보호하기위해서 캡슐화를 하기 위함이다.

또한 생성자에 private을 붙이는 경우도 있는데 이 경우는 싱글톤과 같이 인스턴스를 하나만 만들어 사용하는 경우 메서드를 통해서 하나의 인스턴스만 생성하도록 할 수 있다.

## 제어자의 조합

1. 메서드에 static과 abstract를 함께 사용할 수 없다.

static 메서드는 구현된 메서드에만 사용 가능하다.

2. 클래스에 abstract와 final을 동시에 사용할 수 없다.

그 이유는 final을 붙이면 상속이 불가능하기 때문이다.

3. abstract메서드의 접근 제어자가 private일 수 없다.

private이면 상속 후에 오버라이딩을 못한다..

4. 메서드에 private과 final을 같이 사용할 필요는 없다.

오버라이딩이 불가하다는 의미가 동일하기 때문에 굳이 2개 쓸 필요없다.

## 다형성

다형성이란 조상 클래스 타입의 변수로 자손 클래스 객체를 참조할 수 있는 객체지향의 특징이다.

이를 통해 코드가 특정 구현 클래스에 의존하지 않고 상위 타입(조상 클래스나 인터페이스)에 의존하게 되어, 자손 클래스의 내부 구현이 변경되거나 새로운 자손 클래스가 추가되더라도 기존 코드를 수정하지 않고 쉽게 대체할 수 있다.

다형성을 활용하면 나중에 다른 객체로 변경하는 경우가 있을 때 객체 변경이 용이해져서 유지보수에 좋다.

자세한 건 차차 알아가보자.

일단 설명을 하자면 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 했다는 것이다.

```
조상타입 t = new 자손 클래스() 는 가능하지만 반대의 경우는 불가능하다.
```

그 이유는 자손 클래스가 가지고 있는 멤버의 수가 더 많은데 자손 타입으로 조상 인스턴스를 참조하고 있으면 조상 인스턴스에는 없는 멤버를 호출하면 어떻게 할 것인가?

그렇기 때문에 반대의 경우는 불가능한것이다.

위와 같이 형변환을 사용하면 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위를 조절할 수 있다.

아래 코드 같은 경우가 안된다는 말이다.

```java
Car car = new Car();

FireEngine fe = null;

fe = (FireEngine) car; // 불가능하다.
```

따라서 위와 같이 형변환을 할 때는 instanceof연산자를 사용해서 확인 후에 변환할 수 있도록 한다.

## instanceof

참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위한 연산자다.

true라면 형 변환이 가능하다는 의미다.

```java
if(c instanceof FireEngine) {...}
```

## 참조변수와 인스턴스의 연결

메서드의 경우 오버라이딩한 경우에도 참조 변수의 타입과 관계없이 실제 인스턴스 메서드가 호출된다. 하지만 멤버변수의 경우 참조변수의 타입에 따라 달라진다.

단 중복된 경우만 타입에 영향을 받는다.

```java
class Parent {
    String var = "Parent Variable";

    void printVar() {
        System.out.println("Parent Method");
    }
}

class Child extends Parent {
    String var = "Child Variable"; // 부모와 이름이 같은 변수(중복)

    @Override
    void printVar() {
        System.out.println("Child Method");
    }
}

public class ReferenceExample {
    public static void main(String[] args) {
        Parent p = new Parent();
        Parent pc = new Child();  // 부모 타입 참조, 실제 객체는 Child
        Child c = new Child();

        // 1) 멤버변수 접근 (참조변수 타입 기준)
        System.out.println(p.var);   // Parent Variable
        System.out.println(pc.var);  // Parent Variable (참조 타입이 Parent라 부모 변수 참조)
        System.out.println(c.var);   // Child Variable (참조 타입이 Child라 자식 변수 참조)

        // 2) 메서드 접근 (인스턴스 타입 기준)
        p.printVar();   // Parent Method
        pc.printVar();  // Child Method
        c.printVar();   // Child Method
    }
}

```

## 매개변수의 다형성

매번 다른 객체를 넘겨받으면 그만큼 많은 메서드가 필요하다. 하지만 다른 객체들의 조상클래스를 매개변수의 참조타입으로 가지고 있다면 여기 안에 자손 객체들을 받을 수 있어서 불필요한 메서드들의 정의를 줄일 수 있다.

코드를 통해보자.

```java
// 부모 클래스
class Animal {
    public void sound() {
        System.out.println("Some animal sound");
    }
}

// 자식 클래스들
class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Woof! Woof!");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Meow~ Meow~");
    }
}

// 매개변수의 다형성을 활용한 클래스
class Zoo {
    // 매개변수를 부모 타입으로 선언
    public void makeSound(Animal animal) {
        animal.sound(); // 실제 객체 타입에 따라 오버라이딩된 메서드 실행
    }
}

public class PolymorphismExample {
    public static void main(String[] args) {
        Zoo zoo = new Zoo();

        Dog dog = new Dog();
        Cat cat = new Cat();

        // 매개변수 타입은 Animal이지만 Dog, Cat 전달 가능
        zoo.makeSound(dog);  // Woof! Woof!
        zoo.makeSound(cat);  // Meow~ Meow~
    }
}

```

위와 같이 조상 클래스를 타입으로 가지고 않았다면 아래와 같이 동일한 이름의 메서드를 두 개 만들었어야 했다. 하지만 객체들이 더 많았다면??... 어휴.. 상상만해도 싫다...

```java
public void makeSound(Dog dog) { dog.sound(); }
public void makeSound(Cat cat) { cat.sound(); }
```

## 추상클래스와 인터페이스 차이

둘 다 new 키워드를 사용해 인스턴스를 생성하지 못한다.

그리고 사용하기위해서는 하위 클래스에서 구현/확장 해야 한다.

차이점은 인터페이스는 인터페이스를 구현하는 모든 클래스에서 반드시 특정 메서드가 있어야 함을 강제한다.

하지만 추상클래스는 상속 받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용한다.

즉 공통적인 로직은 추상클래스에 두고 변하는 부분만 추상 메서드로 남겨서 자식 클래스에서 구현하도록 할 수 있다.

추상 클래스는 다중 상속이 불가능하지만 인터페이스는 다중 상속이 가능하다.
