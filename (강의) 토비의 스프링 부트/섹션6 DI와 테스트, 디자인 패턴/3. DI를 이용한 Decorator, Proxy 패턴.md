### Decorator

<center>
  <img
    src="https://github.com/user-attachments/assets/94633d1b-e4b7-44d9-9b9a-9f722d72573e"
    width="50%"
  />
</center>

Decorator 패턴은 위 사진을 보면 알 수 있듯이 기존에 오브젝트들이 존재하고 중간에 Decorator라는 오브젝트를 둬서 동적으로 기능을 추가하거나 책임을 추가하는 등의 작업을 수행할 수 있다.

그러나 Decorator도 Service 인터페이스를 구현하기 때문에 Service 인터페이스를 구현한 빈이 2개가 되는 현상이 발생한다.

이렇게되면 Controller에서 어떤 빈을 의존할지 그리고 Decorator에서는 Service를 구현한 어떤 클래스를 의존할지 몰라서 제대로 동작이 안되게된다.

그래서 Decorator 쪽에 @Primary라는 어노테이션을 추가해서 여러 개의 빈 중 기본으로 사용할 빈이라는 것을 알린다.

그럼 Controller가 Decorator를 의존하는 형식으로 제대로 동작하게된다.

```java
@Service
@Primary // 우선 순위를 지정해준다.
public class HelloDecorator implements HelloService {

	private final HelloService helloService;

	public HelloDecorator(HelloService helloService) {
		this.helloService = helloService;
	}

	@Override
	public String sayHello(String name) {
		return "*" + helloService.sayHello(name) + "*";
	}
}

```
