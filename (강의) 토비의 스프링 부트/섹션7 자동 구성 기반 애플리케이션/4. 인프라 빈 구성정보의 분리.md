`ServletWebServerFactory`, `DispatcherServlet` 은 애플리케이션 인프라스트럭처 빈에 해당한다고 했었다.

그래서 저 두 가지는 우리가 직접 등록하지 않아도 자동으로 등록이 되게 만들어야한다. 하긴 우리가 실제로 작성하는 비즈니스 로직에만 집중하기 위해서는 그게 낫겠다. 그리고 저거를 프로젝트 할 때마다 매번 코드를 작성해서 빈으로 등록하는 것도 번거로울 것 같다.

그래서 componentScan의 대상에서 제외시키는 작업을 먼저 해볼 것이다. 그럼 일단 패키지를 분리한다.

config라는 패키지를 만들어서 이 패키지 안에 저 두 가지를 만드는 코드를 이동시켰다.

그리고 서블릿 컨테이너를 만드는 코드는 톰캣이 아닌 다른 기술로 변경이 될 수 있다.

그래서 서블릿 컨테이너를 생성하는 코드와 DispatcherServlet을 만드는 코드는 분리할 것이다.

```java
@Configuration
public class DispatcherServletConfig {
	@Bean
	public DispatcherServlet dispatcherServlet() {
		return new DispatcherServlet();
	}

}

@Configuration
public class TomcatWebServerConfig {
	@Bean
	public ServletWebServerFactory servletWebServerFactory() {
		return new TomcatServletWebServerFactory();
	}

}
```

`DispatcherServletConfig`, `TomcatWebServerConfig` 총 2개의 파일로 분리가 됐다.

하지만 다른 패키지로 분리가 됐기 때문에 ComponetScan의 대상에서 빠졌기 때문에 프로그램 동작이 제대로 되지않는다.

빈으로 등록한다는 것을 알려야하기 때문에 기존에 만들었던 @MySpringBootApplication에 @Import를 통해 빈으로 등록한다는 것을 알릴 수 있다.

하지만 이렇게 자동 구성 정보가 늘어나면 Import 쪽의 코드가 계속 늘어나면서 최상위 메타 애노테이션인 @MySpringBootApplication이 지저분해질 것이다.

그래서 Import 부분을 또 다른 메타 애노테이션으로 분리하고 분리한 애노테이션을 MySpringBootApplication에 포함되도록 만들 것이다.

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Import({DispatcherServletConfig.class, TomcatWebServerConfig.class}) // 다른 패키지에 있지만 class 정보 넘겨주면 구성 정보로 추가 가능
public @interface EnableMyAutoconfiguration {
}

// Import가 포함된 메타애노테이션을 포함시킴
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE) // class, interface, enum에 적용
@Configuration
@ComponentScan
@EnableMyAutoconfiguration
public @interface MySpringBootApplication {

}
```

그림으로 표현하면 아래와 같이 기존에는 구조가 있었다.

<center>
  <img
    src="https://github.com/user-attachments/assets/ac3de899-8143-483c-a503-ed9880a79302"
    width="50%"
  />
</center>

하지만 리팩토링 후 아래와 같이 구조가 변경이 됐다.

<center>
  <img
    src="https://github.com/user-attachments/assets/e618b4f5-557a-4f67-aa09-1d92d654b57a"
    width="50%"
  />
</center>
