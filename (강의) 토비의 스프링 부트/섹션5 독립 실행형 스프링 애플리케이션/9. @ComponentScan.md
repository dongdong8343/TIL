자바 코드로 구성 정보를 사용하는 것보다 더 편리하게 빈을 등록하는 방법이 존재한다.

구성 정보를 가지고 있는 클래스의 클래스 레벨에 @ComponentScan이라는 애노테이션을 붙인다. 그럼 해당 클래스의 하위 패키지들을 탐색하면서 빈을 찾기 시작한다.

그럼 어떤 클래스가 빈인지 파악할 수 있을까?

바로 클래스 레벨에 @Component라는 애노테이션을 붙이면 빈으로 등록될 애노테이션이라는 것을 알 수 있게된다.

근데 단순히 @Component라고만 작성을 하면 해당 클래스가 어떤 계층인지 바로 판단하는 것이 어렵다는 단점이 있다.

```java
@Configuration
@ComponentScan
public class TobyspringbootApplication {

	public static void main(String[] args) {
		...
	}

}
```

```java
@Component
public class HelloController { // 컨트롤러 -> 유저의 요청 사항을 검증하는 역할

	private final HelloService helloService;

	public HelloController(HelloService helloService) {
		this.helloService = helloService;
	}

	@GetMapping("/hello")
	@ResponseBody
	public String hello(@RequestParam("name") String name) {
		return helloService.sayHello(Objects.requireNonNull(name));
	}
}
```

그래서 스프링은 메타 애노테이션이라는 것을 제공한다. 애노테이션 위의 애노테이션이라는 뜻이다.

대표적으로 @Controller라는 애노테이션이 있는데 안에 들어가보면 @Component라는 것을 포함하고 있는 것을 확인할 수 있다.

그래서 클래스 레벨에 @Controller라는 애노테이션을 붙이면 어떤 계층의 빈인지 파악하는 것이 쉬워진다.

추가로 @RestController라는 것이 있는데 @Controller를 포함하고 있다. 기본적으로 @Controller는 뷰 리졸버를 통해 결과를 리턴한다. 하지만 RestApi를 만들면 Json과 같은 형식으로 결과를 리턴하기를 바란다.

그럴려면 @ResponseBody라는 애노테이션을 붙여야하는데 이를 @RestController가 포함하고 있다. 그래서 @RestController라는 애노테이션 하나만 붙여주면 되는 것이다.

```java
@RestController
public class HelloController {

	...
}

@Service
public class SimpleHelloService implements HelloService {
	@Override
	public String sayHello(String name) {
		return "hello " + name;
	}
}

```
