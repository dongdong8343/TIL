OrderService에 기술과 관련된 코드들은 분리해서 기술이 변해도 Service의 코드가 변경되는 일은 없다.

하지만 트랜잭션은 하나의 작업단위이기 때문에 Service 안에 작성돼야한다.

TransactionTemplate, transactionManager는 각 메서드마다 등장하게 된다. 계속 반복되는 코드다 보니 없애고 싶다..

### 데코레이터 패턴

<center>
      <img
          src="https://github.com/user-attachments/assets/96dd22bc-ab66-4bc9-b164-fef11f9d2892"
          width="100%"
      />
</center>

오브젝트의 코드를 변경하지않고 새로운 기능을 런타임에 부여하는 디자인 패턴을 말한다.

### 프록시 패턴

<center>
      <img
          src="https://github.com/user-attachments/assets/66c4711e-5335-4044-8b0a-b612830c3eb1"
          width="100%"
      />
</center>

타깃을 대신해서 진짜인 척 존재하고 접근을 제거하거나 보안, 지연, 원격 접속 등의 기능을 제공한다.

### 트랜잭션 프록시

<center>
      <img
          src="https://github.com/user-attachments/assets/5909141d-986b-40cd-93b2-b3a9bf17f225"
          width="100%"
      />
</center>

1. OrderService 인터페이스 추출

   ```java
   public interface OrderService {
       Order createOrder(String no, BigDecimal total);

       List<Order> createOrders(List<OrderRequest> requests);
   }
   ```

2. 트랜잭션 부가 기능을 제공하는 OrderServiceTxProxy 프록시 생성

   프록시 안에 실제 오브젝트인 target을 줘서 트랜잭션 내부에서 동작이 일어날 수 있도록 target 메서드를 호출하는 방식으로 동작한다.

   ```java
   public class OrderServiceTxProxy implements OrderService {
       private final OrderService target;
       private final PlatformTransactionManager transactionManager;

       public OrderServiceTxProxy(OrderService target, PlatformTransactionManager transactionManager) {
           this.target = target;
           this.transactionManager = transactionManager;
       }

       @Override
       public Order createOrder(String no, BigDecimal total) {
           return new TransactionTemplate(transactionManager).execute(status ->
               target.createOrder(no, total)
           );
       }

       @Override
       public List<Order> createOrders(List<OrderRequest> requests) {
           return new TransactionTemplate(transactionManager).execute(status ->
               target.createOrders(requests)
           );
       }
   }
   ```

3. 트랜잭션 안에서 작업하는 코드는 OrderServiceImpl에서 수행하게 만든다.

4. OrderConfig에서 OrderService 빈을 만들 때 프록시를 만들고 내부에 실제 구현체를 생성자를 통해 넣는 방식으로 수정

   ```java
   @Configuration
   @Import(DataConfig.class)
   public class OrderConfig {
       @Bean
       public OrderService orderService(OrderRepository orderRepository, PlatformTransactionManager transactionManager) {
           return
               new OrderServiceTxProxy(
                   new OrderServiceImpl(orderRepository),
                   transactionManager
               );
       }

       @Bean
       public OrderRepository orderRepository(DataSource dataSource) {
           return new JdbcOrderRepository(dataSource);
       }
   }
   ```

   - 위와 같은 방식으로 수정함으로써 JDBC를 사용하던 JPA를 사용하던 트랜잭션을 보장하게되고 다른 기술을 사용해도 실제 구현된 OrderServiceImpl의 코드가 변경될 일은 없다.
