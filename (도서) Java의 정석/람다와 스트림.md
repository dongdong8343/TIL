## 람다란 무엇인가?

람다는 간단하게 말하면 메서드를 식 형태로 표현하는 것을 말한다.

```java
Arrays.setAll(arr, (i) -> (int)(Math.random() * 5) + i);
```

메서드의 이름과 반환 값이 없어지므로 익명 함수라고 하기도 한다.

람다식은 아래와 같이 작성할 수 있다.

```java
반환타입 메서드이름 (매개변수 선언) {
    문장들
}

=>

(매개변수 선언) -> {}

// 만약 {} 안에 들어갈 문장이 하나라면 {}는 생략 가능하다.
```

### 함수형 인터페이스

함수형 인터페이스는 하나의 추상 메서드만 정의되어 있다.

```java
// 해당 어노테이션을 붙임으로써 함수형 인터페이스를 제대로 작성했는지 컴파일러가 파악 가능
@FunctionalInterface
interface MyFunction {
    public abstract int max(int a, int b);
}
```

만약 람다가 없었다면 위 인터페이스를 구현하기 위해서 익명 클래스를 사용했을 것이다.

```java
MyFunction fun = new MyFunction() {
    @Override
    public int max (int a, int b) {
        return a > b ? a : b;
    }
}
```

하지만 람다가 있다면 아래와 같이 간편하게 사용할 수 있다.

```java
MyFunction fun = (a, b) -> a > b ? a : b;
```

### 메서드 참조

람다를 통해서 충분히 코드를 줄였지만 여기서 더 줄일 수 있다.

```java
Function<String, Integer> f = (String s) -> Integer.parseInt(s);
```

위와 같은 문장을 메서드 참조를 사용하면 더 줄일 수 있다.

```java
Function<String, Integer> f = Integer::parseInt;
```

람다의 일부분이 생략됐는데 이 부분은 좌변의 제네릭 또는 우변을 보고 컴파일러는 파악할 수 있다.

## 스트림

컬렉션 클래스에는 같은 기능의 메서드들이 중복돼 정의되어있다.

그렇다면 서로 다른 컬렉션 클래스를 사용할 때 매번 다른 메서드의 이름을 호출해야 한다는 단점이 있다.

하지만 스트림을 사용하면 데이터의 흐름을 추상화하고 일관된 방식으로 대량의 데이터를 처리할 수 있다.

즉 모두 같은 방식으로 데이터를 다룰 수 있게 됐다.

또한 다음과 같은 특징을 가지고 있다.

1. 지연 연산 - 최종 연산이 수행되기 전까지 중간 연산이 수행되지않는다는 특징이 있다.

2. 병렬 스트림 - 병렬 처리가 쉽다는 장점이 있다. 그저 아래와 같이 스트림에 parallelStream()을 붙여주면 된다.

```java
List<Integer> numbers = IntStream.rangeClosed(1, 10).boxed().toList();

numbers.parallelStream()
    .forEach(i -> {
        System.out.println(Thread.currentThread().getName() + " -> " + i);
    });

```

### 자주 사용되는 문법

1. 변환 - map()

```java
List<UserDTO> dtos = users.stream()
    .map(UserDTO::fromEntity)
    .toList();
```

2. 필터링 - filter()

```java
List<User> adults = users.stream()
    .filter(u -> u.getAge() >= 18)
    .toList();
```

3. 정렬 - sorted()

```java
List<Product> sorted = products.stream()
    .sorted(Comparator.comparing(Product::getPrice).reversed())
    .toList();
```

4. 중복제거 - distinct()

```java
List<String> uniqueNames = names.stream()
    .distinct()
    .toList();
```

5. 수집 - collect()

```java
Map<Long, User> userMap = users.stream()
    .collect(Collectors.toMap(User::getId, u -> u));
```

6. 변환 - flatMap()

중첩된 리스트를 펼쳐서 하나의 스트림으로 만들어준다.

아래 코드는 여러 유저들이 주문한 목록들을 하나의 리스트로 만드는 코드다.

한 명의 유저당 여러 주문이 있는데 이 주문들을 flatMap을 사용해서 하나의 리스트로 만들 수 있다.

```java
// User : Order = 1 : N
List<Order> allOrders = users.stream()
    .flatMap(user -> user.getOrders().stream())
    .toList();
```

## Optional<T>

최종 연산의 결과가 Optional인 경우도 있다.

우리가 JPA를 사용해서 결과를 받으면 Optional로 반환하는 경우를 봤을 것이다.

그렇다면 Optional은 뭘까?

null을 효율적으로 처리하기 위해 사용하는 래퍼 클래스다.

즉 반환된 결과를 if문을 통해 확인하는 것이 아니라 Optional에 정의된 메서드를 통해 확인할 수 있다.

```java
// Spring Data JPA Repository
Optional<User> userOpt = userRepository.findById(userId);

// 방식 1: 값이 있으면 반환, 없으면 예외
User user = userOpt.orElseThrow(() -> new EntityNotFoundException("사용자 없음"));

// 방식 2: 기본값 제공
User user = userOpt.orElse(new User("guest"));

// 방식 3: 존재하면 동작 수행
userOpt.ifPresent(u -> log.info("로그인: {}", u.getName()));

// 방식 4: DTO로 변환
UserDTO dto = userRepository.findByEmail(email)
    .map(UserDTO::fromEntity)   // Optional<User> → Optional<UserDTO>
    .orElseThrow(() -> new IllegalArgumentException("이메일 없음"));
```
